\documentclass[12pt,a4paper]{report}
\ifx\pdftexversion\undefined
	\usepackage[dvips]{graphicx}
\else
	\usepackage[pdftex]{graphicx}
	\DeclareGraphicsRule{*}{mps}{*}{}
\fi
\usepackage{filecontents}
\usepackage{longtable}
\graphicspath{{./figures/}}
\newcommand{\code}{\texttt}

\begin{filecontents*}{originality.sty}
	\NeedsTeXFormat{LaTeX2e}
	\ProvidesPackage{originality}
	\newenvironment{originality}
	{\renewcommand{\abstractname}{Originality Avowal}
		\begin{abstract}}
	{\end{abstract}
		\clearpage}
	\endinput
\end{filecontents*}
\usepackage{originality}

\begin{filecontents*}{acknowledgements.sty}
	\NeedsTeXFormat{LaTeX2e}
	\ProvidesPackage{acknowledgements}
	\newenvironment{acknowledgements}
	{\renewcommand{\abstractname}{Acknowledgements}
		\begin{abstract}}
	{\end{abstract}
		\clearpage}
	\endinput
\end{filecontents*}
\usepackage{acknowledgements}

\begin{document}
	\begin{titlepage}
		\centering
		{\huge\bfseries Trustery: An Identity System Based on Smart Contracts on the Blockchain\par}
		\vspace{1cm}
		{\Large\scshape Final Project Report\par}
		\vspace{1.5cm}
		{\Large\itshape Mustafa Al-Bassam\par}
		\vfill
		{\LARGE\scshape King's College London\par}
		\vfill
		{\large \today\par}
	\end{titlepage}
	
	\begin{abstract}
		test
	\end{abstract}
	
	\begin{acknowledgements}
		test
	\end{acknowledgements}
	
	\begin{originality}
		I verify that I am the sole author of this report, except for the content of this originality avowal and where explicitly stated to the contrary.
		
		I grant King's College London the right to make paper and electronic copies of the submitted work for purposes of marking, plagiarism detection and archival, and to upload a copy of the work to a trusted plagiarism detection service. I confirm this report does not exceed 25,000 words.
		
		\bigskip
		\noindent Mustafa Al-Bassam\newline
		\today
	\end{originality}
	
	\tableofcontents
	
	\chapter{Introduction}
	\section{Motivation}
	The motivation for this project to build an identity system based on smart contracts on the blockchain arises from two problems, outlined in this section.
	
	\subsection{Centralisation and Security Weaknesses of Public Key Infrastructure}
	The secure operation of SSL/TLS relies on a set of trusted Certificate Authorities (CAs) to authenticate public keys\cite{1}. In practice, the set of trusted CAs are bundled into operating systems and web browsers. Therefore, the Public Key Infrastructure (PKI) is centralized as only CAs chosen by operating system and web browser vendors may issue globally valid certificates.

	This system is exclusive; it is expensive and time-consuming to convince operating system and web browser vendors to bundle a CA, therefore entities must usually pay CAs to sign their public keys. For example, it typically takes over 11 months to apply for root CA inclusion in Mozilla products\cite{6}.
	 
	A major security weakness of this system is that every CA has the ability to issue rogue certificates for any entity. In 2011 the DigiNotar CA issued a rogue certificate for Google which was reported to be used in attempted man-in-the-middle attacks against Google users\cite{7}.

	PGP is a data encryption and decryption standard that does not use CAs to verify the authenticity of public keys. Instead, it offers a feature that allows individuals to sign other individuals' public keys to certify their authenticity. This creates a web-of-trust model that can navigated to determine the authenticity of public keys belonging to individuals that have no pre-shared secret with each other.\cite{2}

	The web-of-trust model is a first step towards a decentralized PKI. However, PGP itself is not a PKI as it does not provide a way to retrieve public keys. Commonly, PKI for PGP is implemented as centralized keyservers (such as pgp.mit.edu) that are used to query for public keys.

	Ideally, a PKI for PGP would be be fully decentralized and not rely on centralized servers. Centralized keyservers act as a central point of failure that also allow for censorship, exclusion and alteration of keys by a third party.
	
	\subsection{Identity}
	The X.509 standard for certificates on the Internet provides scope for a wide range of identity attributes to be embedded in certificates.\cite{8} Identity attributes include information such as phone number, address and name. This provides a way for certificate authorities to vouch for the identity associations of an organization's online presence.
	
	Adapting this system in a web-of-trust PKI model as described above opens the door for a wide range of identity-related problems to be solved, in contexts where an organization or an individual needs to verify a fact about another organization or individual without trusting paper records that can easily be spoofed unlike cryptographic records.
	
	For example, when an employer needs to verify a potential employee's degree certification, the degree-awarding university can cryptographically sign a degree, and the branch of the government responsible for giving universities degree-awarding powers can cryptographically sign the university's degree-awarding certification. The employer only needs to search the webs-of-trust to trust the branch of the government that is responsible for giving universities degree-awarding powers, and work through the remaining chain-of-trust.
	
	Other examples could be verifying a company's shareholders and directors, verifying the visa of an traveller or verifying the driving license of a citizen.
	
	This not easily possible with the current X.509 certificate standard because the standard does not allow certificate authorities to sign specific and fine-grained attributes in a certificate; certificate authorities must sign the entire certificate or nothing.
	
	
	\section{Aims}
	The aim of this project is to materialize the decentralized public key infrastructure and identity management system as described above.
	
	Specifically, this project will create a system based on a smart contract on the Ethereum blockchain that will enable users to manage identities and attributes associated with identities, including cryptographic keys.
	
	The system will be decentralized and will allow users to sign and verify specific and fine-grained attributes of identities using a web-of-trust model.
	
	\chapter{Background review}
	\section{Blockchain}
	The	concept of the blockchain was introduced in 2008 by Satoshi Nakamoto in the Bitcoin electronic cash system.\cite{9} Bitcoin is designed as a peer-to-peer network where nodes running the Bitcoin software relay transactions to other nodes. To prevent cash from being double spent, the network reaches a consensus on the ordering of transactions by recording them on the blockchain; the Bitcoin paper describes a process of timestamping transactions by "hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work".
	
	In the Bitcoin network the proof-of-work involves repeatedly hashing blocks of incoming transactions until a hash is found that begins with a certain number of zero bits. This requires CPU power, and so as long as the majority of the CPU power on the network is not controlled by a central authority, a central authority cannot modify the blockchain and reverse transactions. This is because the consensus rule of the network is such that the blockchain with the biggest number of blocks is the correct one, and so an authority that does not have the majority of the network's CPU power is unlikely to outpace the creation of blocks of the rest of the network.
	
	The peer-to-peer nature of the Bitcoin blockchain and the fact that it is designed so that it is computationally expensive (and hence theoretically economically unattractive) for a central authority to take control of the blockchain and reverse transactions makes it a suitable tool to satisfy the decentralized aim of this project.
	
	The idea of this project is therefore to exploit the decentralized data storage and consensus capabilities of the blockchain to store identities and keys for a public key infrastructure, rather than transactions for a cash system.
	
	\subsection{Smart Contracts and Ethereum}
	Each Bitcoin transaction references other transactions (called inputs) and creates outputs, which are recorded on the Bitcoin blockchain. The Bitcoin in these outputs can then be "spent" by other transactions. To facilitate the creation of transactions, Bitcoin has a transaction scripting language that is used to specify "locking scripts" for specifying conditions that must be met to spend transaction outputs.\cite{10}
	
	Since the invention of Bitcoin, other forms of blockchain-based systems have emerged that extend the scripting language beyond the purpose of a cash system, to allow for other types of applications to be expressed on the blockchain in the form of "smart contracts". 
	
	One such blockchain-based system for smart contracts is Ethereum. The Ethereum white paper describes smart contracts as "complex applications involving having digital assets being directly controlled by a piece of code implementing arbitrary rules".\cite{3}
	
	\section{Public Key Infrastructure}
	\subsection{Certificate Authorities}
	\subsection{Web of Trust}
	\section{Alternative Identity and Public Key Infrastructure systems}
	
	\chapter{Requirements \& Specification}
	\section{Brief}
	The purpose of this project is to create a system hosted on the Ethereum blockchain and controlled by a smart contract, that allows entities to manage (such as storing, retrieving and verifying in a web-of-trust) identities of itself and other entities.
	
	An entity refers to any participant in the system and may be human or non-human, such as a person, organization or autonomous agent.
	
	An identity is a set of attributes about an entity such as cryptographic keys, names or addresses.
	
	\section{User Stories}
	\begin{itemize}
		\item As a user, I want to publicly publish attributes about myself (my identity) so that other users can act on them.
		\item As a user, I want to search and retrieve attributes about other users so that I can act on them.
		\item As a user, I want to sign attributes of other users so that other users are more likely to trust these attributes (for example if the other users also trust me).
		\item As a user, I want to know which users trust the attributes of other users so that I can decide whether to trust these attributes or not.
		\item As a user, I want to manage my personal list of trusted identities.
		\item As a user, I want to publicly publish my PGP key as an attribute of my identity so that other users can encrypt to me.
		\item As a user, I want to search and retrieve the PGP keys of other users so that I can encrypt to them.
	\end{itemize}
	
	\section{Functional Requirements}
	The functional requirements are categorized into two sections:
	\begin{itemize}
		\item The requirements for the smart contract on the blockchain. This represents the rules and the protocol of the system.
		\item The requirements for the client that interacts with the blockchain using the rules of the smart contract.
	\end{itemize}		
	
	\subsection{Smart Contract}
	\begin{itemize}
		\item Entities can publish attributes about themselves (their identity) on the blockchain.
		\item Data associated with attributes may be stored off the blockchain (for example on IPFS or any arbitrary URI) and linked to from attributes.
		\item Data associated with attributes that may be stored off the blockchain can have cryptographic hashes representing them published as part of the attributes in the blockchain.
		\item Entities can sign attributes about entities and publish signatures on the blockchain.
		\item Entities can revoke their own signatures published on the blockchain.
		\item Signatures can have optional expiry dates.
		\item If an attribute is a cryptographic key, an entity can publish cryptographic proof of ownership of the key on the blockchain. Proof of ownership proves that the entity that published the attribute has access to the private keys of a key.
	\end{itemize}
	
	\subsection{Client}
	\begin{itemize}
		\item All of the actions that the smart contract allows can be performed by the client.
		\item Users can search attributes about identities (entities) from the blockchain.
		\item Users can retrieve attributes about identities from the blockchain.
		\item Users can retrieve the signatures associated with an attribute.
		\item Whether signatures are valid or not should be reflected in the client.
		\item Users can mark identities as trusted or untrusted in personal trust-stores.
		\item Users can view a list of the trusted identities in their trust-store.
		\item Whether an identity is trusted or not is reflected in the client when displaying identities.
		\item The client can automatically verify the cryptographic proof of ownership of PGP key attributes associated with identities or their attributes.
		\item Users can publish their PGP key and its associated cryptographic proof of ownership which is automatically generated by the client.
		\item Where data associated with an attribute is stored off the blockchain, the client can automatically publish attributes with data that is stored using an IPFS or HTTP(S) URI and generate a cryptographic hash associated with the data if necessary.
		\item Where data associated with an attribute is stored off the blockchain, the client can automatically retrieve data that is stored using an IPFS or HTTP(S) URI and verify the data using its published cryptographic hash if necessary.
	\end{itemize}
	
	\section{Non-functional Requirements}
	\begin{itemize}
		\item The system must be secure. Specifically, this means that:
			\begin{itemize}
				\item data in the blockchain cannot be modified in an unauthorized manner;
				\item the integrity of data and attributes retrieved from the blockchain and off the blockchain must be verified by the client (such as the cryptographic hash of data stored off the blockchain and proof of ownership of cryptographic keys).
			\end{itemize}
		\item The system should be reliable. All actions of the smart contract can be performed regardless of the state of the system.
		\item The client should be able to run on most common modern operating systems.
		\item The financial cost of using the system resulting from blockchain transaction fees should be minimized.
		\item The system should be scalable to many identities and attributes.
	\end{itemize}
	
	\section{Specification}
	The below tables outline the specification for each of the requirements of the smart contract and client, and the non-functional requirements.	
	
	\subsection{Smart Contract}
	The smart contract is to be written in Solidity, a programming language for writing Ethereum smart contracts.
	
	\noindent \begin{longtable}{|p{5.5cm}|p{5.5cm}|}
		\hline
		\textbf{Requirement} & \textbf{Specification} \\ \hline
		Entities can publish attributes about themselves (their identity) on the blockchain. & Identities are represented by Ethereum addresses. The smart contract will have an \textit{add attribute} transaction which will generate an \textit{add attribute} event with a unique attribute ID. \\ \hline
		Data associated with attributes may be stored off the blockchain (for example on IPFS or any arbitrary URI) and linked to from attributes. & The \textit{add attribute} transaction will have a parameter for specifying data, that supports linking to data that is stored off the blockchain. \\ \hline
		Data associated with attributes that may be stored off the blockchain can have cryptographic hashes representing them published as part of the attributes in the blockchain. & The \textit{add attribute} transaction will have a parameter for specifying a SHA256 hash. \\ \hline
		Entities can sign attributes about entities and publish signatures on the blockchain. & The smart contract will have a \textit{sign attribute} transactionwhich will generate a \textit{sign attribute} event with a unique signature ID. \\ \hline
		Entities can revoke their own signatures published on the blockchain. & The smart contract will have a \textit{revoke signature} transaction which will generate an \textit{revoke signature} event with a unique revocation ID. \\ \hline
		Signatures can have optional expiry dates. & The \textit{sign attribute} transaction will have a parameter to specify an expiry date. \\ \hline
		If an attribute is a cryptographic key, an entity can publish cryptographic proof of ownership of the key on the blockchain. Proof of ownership proves that the entity that published the attribute has access to the private keys of a key. & The \textit{add attribute} transaction will have a boolean parameter to flag that a cryptographic proof is attached to the data of the attribute. \\ \hline
	\end{longtable}
	
	\subsection{Client}
	The client is to be implemented as a command-line text-based console application written in Python.
	
	\noindent \begin{longtable}{|p{5.5cm}|p{5.5cm}|}
		\hline
		\textbf{Requirement} & \textbf{Specification} \\ \hline
		All of the actions that the smart contract allows can be performed by the client. & There will be console commands for adding attributes, signing attributes and revoking signatures. The commands will take input from the user and form the parameters for each transaction, and communicate with the Ethereum JSON RPC to send the transactions. \\ \hline
		Users can search attributes about identities (entities) from the blockchain. & There will be a console command for searching attributes. The command will take input from the user about the parameters to filter the attributes by, and communicate with the Ethereum JSON RPC to filter event logs of added attributes. \\ \hline
		Users can retrieve attributes about identities from the blockchain. & There will be a console command for retrieving attributes based on the attribute's ID, which will communicate with the Ethereum JSON RPC to filter a single attribute by its ID. \\ \hline
		Users can retrieve the signatures associated with an attribute. & The command for retrieving attributes will also retrieve and display the attribute's signatures by filtering signatures with the attribute's ID using the Ethereum JSON RPC. \\ \hline
		Whether signatures are valid or not should be reflected in the client. & The client will check the expiry date associated with each signature and search the event logs for revocations associated with each signature using the Ethereum JSON RPC. \\ \hline
		Users can mark identities as trusted or untrusted in personal trust-stores. & There will be a console command to add and remove Ethereum addresses from the list of trusted identities, which will be stored in a local file. \\ \hline
		Users can view a list of the trusted identities in their trust-store. & There will be a console command that displays the list of trusted identities. \\ \hline
		Whether an identity is trusted or not is reflected in the client when displaying identities. & Each Ethereum address displayed by the various console commands will have an indicator next to it when it is found in the trust-store. \\ \hline
		The client can automatically verify the cryptographic proof of ownership of PGP key attributes associated with identities or their attributes. & When a PGP attribute is retrieved, the client will invoke the local GPG binary to verify the signature associated with the attribute data. \\ \hline
		Users can publish their PGP key and its associated cryptographic proof of ownership which is automatically generated by the client. & There will be a console command to publish PGP key attributes that invokes the local GPG binary to retrieve the PGP keys and generate signatures for cryptographic proofs of ownership. \\ \hline
		Where data associated with an attribute is stored off the blockchain, the client can automatically publish attributes with data that is stored using an IPFS or HTTP(S) URI and generate a cryptographic hash associated with the data if necessary. & The add attribute console command will detect when a HTTP(S) URI is used as input for the data field of an attribute, and automatically download the data over HTTP and generate a SHA256 hash for the data. For IPFS URIs it is not necessary to generate a hash as IPFS URIs include a hash. \\ \hline
		Where data associated with an attribute is stored off the blockchain, the client can automatically retrieve data that is stored using an IPFS or HTTP(S) URI and verify the data using its published cryptographic hash if necessary. & The retrieve attribute console command will detect when an IPFS or HTTP(S) URI populates the data field of an attribute, automatically download the data over IPFS or HTTP and verify the SHA256 hash associated with the data in the case of HTTP(S) URIs. \\ \hline
	\end{longtable}
	
	\subsection{Non-functional Requirements}	
	\begin{longtable}{|p{5.5cm}|p{5.5cm}|}
		\hline
		\textbf{Requirement} & \textbf{Specification} \\ \hline
		Security: Data in the blockchain cannot be modified in an unauthorized manner. & This is enforced by the Ethereum protocol itself as miners validate all transactions before being included in blocks. \\ \hline
		Security: The integrity of data and attributes retrieved from the blockchain and off the blockchain must be verified by the client (such as the cryptographic hash of data stored off the blockchain and proof of ownership of cryptographic keys). & The client will check that the SHA256 hash of data stored off the blockchain matches with the published hash. When a PGP attribute is retrieved, the client will invoke the local GPG binary to verify the signature associated with the attribute data. \\ \hline
		The system should be reliable. All actions of the smart contract can be performed regardless of the state of the system. & The smart contract will be implemented so that each attribute is stored independently of each other. This is also partly a condition of the Ethereum protocol itself as each smart contract has a state that is independent of other smart contracts. \\ \hline
		The client should be able to run on most common modern operating systems. & The client will be implemented in Python, which is a cross-platform language. \\ \hline
		The financial cost of using the system resulting from blockchain transaction fees should be minimized. & The smart contract will be implemented in a way that uses the least operations and stores the least data possible on the blockchain so that the gas price of each transaction is minimized. \\ \hline
		The system should be scalable to many identities and attributes. & The Ethereum JSON RPC allows for events to be filtered by specified indexed parameters such attribute ID, attribute owner, etc. \\ \hline
	\end{longtable}
	
	\chapter{Design}
	\section{Smart contract}
	The smart contract is the interface on the blockchain that sets the rules for the management and storage of identity attributes and keys, that users using the system must abide by.
	
	\subsection{Language}
	Code for Ethereum smart contracts is written in Ethereum Virtual Machine (EVM) code, which is a low-level stack-based bytecode language.\cite{3}
	
	To facilitate the creation of Ethereum smart contracts, several high-level languages for Ethereum exist that are compiled down to EVM code. Two of the main ones are:
	\begin{itemize}
		\item Solidity, a statically typed language with syntax similar to JavaScript.\cite{11}
		\item Serpent, a dynamically typed language with syntax similar to Python.\cite{12}
	\end{itemize}
	
	Although the two languages are similar in that they are both high-level languages that compile down to EVM code, Solidity was chosen as the smart contract language for this project because it is statically typed.
	
	The fact that Solidity is statically typed means that smart contract code published on the blockchain is more likely to be bug-free as type constraints are enforced at compilation time instead of runtime.
	
	Statically typed smart contracts also allow for explicit control of sizes of data specified to contract methods and stored on the blockchain, which is useful for this particular project as the smart contract is intended for arbitrary types of data to specified for certain parameters and predictable types of data for other parameters.
	
	For example, the Serpent compiler command \code{serpent mk\_signature} shows that the Serpent compiler automatically sets variables to be of type \code{uint256} (integers of 256 bits) unless other explicitly stated. This would be inefficient for the storage of the cryptographic proof boolean flag specified in the project's smart contract specification, as the variable would be padded to 256 bits, therefore increasing the gas price of certain transactions in the system. One of the project's non-functional requirements is to minimize the financial cost of the system.
	
	It would therefore be advantageous to use a language where all types must be explicitly specified, because once a smart contract is published on the blockchain its code cannot be modified.
	
	\subsection{Entities}
	Figure 4.1 shows the data entities and their constraints to be defined and manipulated in the smart contract. Solidity allows for the definition of \textit{structs}, a way to define data structures.\cite{13}
	\begin{figure}[!ht]
		\centering
			\includegraphics{"smartcontract.1"}
		\caption{Entity-relationship diagram for the Trustery smart contract.}
	\end{figure}
	
	\bigskip
	\noindent \textbf{\textit{Entity} entity}\newline
	The \textit{entity} entity is not explicitly defined as a data structure in the smart contract. Instead, it is implicit to the implementation of Ethereum.
	
	Each Ethereum transaction has an owner, which is a 20-byte \textit{address} representing a cryptographic public key.\cite{3} For a transaction to be valid, its inputs must be signed using the private key associated with the owner's address.
	
	This makes an Ethereum address a good way to represent an \textit{entity} or a user of the system, as only those who have knowledge of an Ethereum address's private key are able to make transactions on behalf of that address such as adding and signing attributes.
	
	Attributes, signatures and revocations all have one owner entity. For revocations, this is implicit because signature revocations can only be made by the signers of the signatures. For signatures, the owner is referred to as the \textit{signer}.
	
	\bigskip
	\noindent \textbf{Attribute entity}\newline
	The attribute entity represents an attribute about an entity in the system.
	
	\bigskip
	\noindent \textbf{Signature entity}\newline
	
	\bigskip
	\noindent \textbf{Revocation entity}\newline
	
	\subsection{Methods and events}
	
	\section{Client}
	
	\chapter{Implementation}
	
	
	\bibliographystyle{IEEEtran}
	\bibliography{6ccs3prj}
\end{document}